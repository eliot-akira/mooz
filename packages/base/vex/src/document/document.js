/**
 * Document - generic document object to be formatted and displayed
 * @author Daniel Ringwalt (ringw)
 */
module.exports = function(Vex) {

  /**
   * Vex.Flow.Document - generic container of measures generated by a backend
   * @constructor
   */
  Vex.Flow.Document = function(data, options) {
    if (arguments.length > 0) this.init(data, options)
  }

  Vex.Flow.Document.backends = [Vex.Flow.Backend.Json, Vex.Flow.Backend.MusicXML]

  Vex.Flow.Document.prototype.init = function(data, options) {
    this.options = {}
    Vex.Merge(this.options, options)
    this.measures = new Array()
    if (! data) {
      this.backend = null
      return
    }

    // Optionally pass constructor function for backend
    let backends = (typeof this.options.backend == "function")
                 ? [this.options.backend] : Vex.Flow.Document.backends

    // Find a valid backend for the data passed
    for (let i = 0; i < backends.length; i++) {
      let Backend = backends[i]
      if (Backend.appearsValid(data)) {
        this.backend = new Backend()
        this.backend.parse(data)
        if (! this.backend.isValid()) {
          throw new Vex.RERR("ParseError", "Could not parse document data")
        }
      }
    }
    if (! this.backend) {
      throw new Vex.RERR("ParseError", "Data in document is not supported")
    }

    this.type = "document"
  }

  /**
   * Create a formatter with a copy of the document
   * (formatter may add clefs, etc. when formatting document)
   * @param {Function} Class of formatter
   * @return {Vex.Flow.DocumentFormatter} Document formatter with document copy
   */
  Vex.Flow.Document.prototype.getFormatter = function(options) {

    const Formatter = Vex.Flow.DocumentFormatter.Liquid

    return new Formatter(new Vex.Flow.Document(this), options)
  }

  /**
   * Number of measures in the document
   * @return {Number} Total number of measures
   */
  Vex.Flow.Document.prototype.getNumberOfMeasures = function() {
    return this.backend.getNumberOfMeasures()
  }

/**
 * @param {Number} Zero-indexed measure number
 * @return {Number} Actual measure number (default: add 1 to argument)
 */
  Vex.Flow.Document.prototype.getMeasureNumber = function(m) {
    return (typeof this.backend.getMeasureNumber == "function")
         ? this.backend.getMeasureNumber(m) : m + 1
  }

  /**
   * Retrieve the ith measure (zero-indexed).
   * @param {Number} The zero-indexed measure to access.
   * @return {Vex.Flow.Measure} Measure object for corresponding measure
   */
  Vex.Flow.Document.prototype.getMeasure = function(m) {
    if (m in this.measures) return this.measures[m]
    let measure = this.backend.getMeasure(m)
    if (typeof console != "undefined" && console.assert)
      console.assert(measure instanceof Vex.Flow.Measure,
                     "Backend must return valid Vex.Flow.Measure")
    this.measures[m] = measure
    return measure
  }

  Vex.Flow.Document.prototype.getNumberOfParts = function() {
    return this.getMeasure(0).getNumberOfParts() }

  /**
   * Connector options from backend
   * Single connectors are automatically added at the start of the system
   * and for barlines within a single part.
   * @return {Array} array of objects with properties:
   *    type (bracket, brace, single, etc), parts (array of part numbers),
   *    system_start/system_end/measure_start (true/false)
   */
  Vex.Flow.Document.prototype.getStaveConnectors = function() {

    if (typeof this.staveConnectors==='object') return this.staveConnectors

    this.staveConnectors = this.backend.getStaveConnectors().slice(0)

    let haveSingleSystemStart = false // add if necessary
    let numParts = this.getNumberOfParts()
    let lastPart = numParts - 1

    this.staveConnectors.forEach(function(connector) {
      if (connector.type == "single" && connector.parts[0] == 0
        && connector.parts[connector.parts.length - 1] == lastPart
        && (connector.system_start || connector.measure_start))
        haveSingleSystemStart = true
    })

    if (!haveSingleSystemStart) {
      this.staveConnectors.push({
        type: "single", system_start: true, parts: [0, lastPart] })
    }

    // Add barlines to each part if necessary
    let partsHaveBarlines = []

    this.staveConnectors.forEach(function(connector) {
      if (connector.type == "single" && connector.parts.length == 1
        && connector.measure_start && connector.system_end)
        partsHaveBarlines[connector.parts[0]] = true
    })

    for (let i = 0; i < numParts; i++) {
      if (partsHaveBarlines[i]) continue
      this.staveConnectors.push({
        type: "single", parts: [i], measure_start: true, system_end: true
      })
    }

    return this.staveConnectors
  }

  return Vex
}
